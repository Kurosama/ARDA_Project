\chapter{Concluzioni}
In questa tesi si \`e voluto principalmente confrontare lo sviluppo dell'algoritmo
ARDA con 2 linguaggi di programmazione concettualmente diversi tra loro: Java e Python.
In seguito si \`e voluto apportare dei miglioramenti:
\begin{enumerate}
    \item Si \`e voluto riorganizzare il codice per una maggiore fruibilit\`a e leggibilit\`a
    \item Migliorare il calcolo della distanza tra punti e calcolo della matrice $M_{acc}$
\end{enumerate}
Come ultima parte, si \`e voluto implementare un'interfaccia grafica per poter visualizzare
i risultati in modo semplice e veloce, senza dimenticare la possibilit\`a di esportare i
dati in file CSV

\section{Considerazioni}
La conversione del codice da Python a Java, dopo l'attenta analisi del codice e di tutte
le sue funzionalit\`a e varianti, \`e stata abbastanza immediata, non trovando procedure o
funzioni differenti tra i due linguaggi.\\
Invece lo sviluppo dell'interfaccia grafica ha richiesto molta pi\`u attenzione.
Java non da nativamente le possibilit\`a di sviluppare interfacce tramite dei tool esterni
senza generare codice pesante e alle volte molto complesso a fronte delle semplicit\`a dell'interfaccia.
Lo stesso sistema di gestione dei componenti e della loro dimensione e posizione non \`e
intuitivo. Confrontandolo con linguaggi simili come C++ e lo stesso Python che, mediante
librerie grafiche specifiche danno la possibilit\`a creare interfacce grafiche, Java ha una
gestione abbastanza macchinosa per quando riguarda la composizione delle interfacce grafiche.
Stesso discorso vale per la mancanza di vere e proprie librerie per la gestione dei grafici
senza doversi appoggiare a libreria esterne a quelle di Java stessa.\\
Queste mancanze non hanno comportato criticit\`a nello sviluppo del programma ma non hanno
nemmeno agevolato lo sviluppo della parte grafica.

\section{Sviluppi futuri}
In tutto lo scritto ci sono state alcne riflessioni in merito a possibili sviluppi
sia del modello considerato, sia dell'algoritmo.\\
Un possibile sviluppo pu\`o essere l'aumento di variabili analizzate per determianre
l'importanza di un luogo, incorporando all'analisi degli spostamenti terrestri anche
altri fattori di interesse ottenibili da reti sociali oppure da altri applicativi.\\
Nel capitolo 4 si \`e potuto notare come l'algoritmo di calcolo della matrice $M_{imp}$
per l'indece \textit{spaceRank} ha tempi di esecuzione molto elevati. Su questo punto
si potrebbe valutare nuovi approcci per il calcolo dell'autovettore e delle relative
matrici. Una semplice soluzione interessante, anche per gli altri indici, sarebbe quella
di poter tenere memorizzata la matrice di interesse a seconde delle dimensioni delle localit\`a.
Queste poterebbe ad avere una prima esecuzione molto lenta ma per le analisi successive sarebbe
immedaite visto che la criticit\`a \`e proprio nella generazione delle matrici.
Questo avvantaggerebbe anche nuovo immissimo di valori perch\`e comporterebbe l'aggioramento
di una sola cella.
Un'altro sviluppo interessante potrebbe essere lo sviluppo di un servizio web che esegua:
\begin{itemize}
\item Lato server tutta la gestione dell'aggiornamento delle matrici e l'esecuzione della possibile destinazione;
\item Lato client si avrebbe l'invio della posizione al server, la ricezione e la visualizzazione dei dati ottenuti.
\end{itemize}
Un esempio simile pu\`o essere Google Maps
\begin{itemize}
\item Lato server avviene il calcolo dei persorsi pi\`u veloci a seconda delle richieste dell'utente
\item Lato client si ha l'invio delle coordinate e la visualizzazione in tempo reale della mappa e del percorso calcolato dal server.
\end{itemize}
Questo potrebbe anche risolvere i tempi di esecuzione dell'indice \textit{spaceRank} visto
l'enorme potenza di calcolo che gli attuali servizi cloud come Google ed Amazon forniscono alla loro clientela.
